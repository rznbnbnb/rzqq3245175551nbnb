-- Ohio 服务器自动采集脚本 - 修复循环版
-- 自动换服 → 捡物品 → 换服 → 循环
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- 本地玩家引用
local localPlayer = Players.LocalPlayer

-- 配置参数
local CONFIG = {
    SEARCH_RADIUS = 2000,          -- 最大搜索半径
    TELEPORT_DELAY = 0.5,          -- 传送延迟
    SERVER_HOP_DELAY = 1,          -- 换服延迟
    ITEM_PICKUP_DELAY = 1,         -- 捡物品后等待时间
    MAX_RETRY_ATTEMPTS = 5,        -- 最大重试次数
    RETRY_DELAY = 2,               -- 重试延迟
    E_KEY_PRESS_DURATION = 0.2,    -- E键按下持续时间
    E_KEY_PRESS_COUNT = 3,         -- E键按下次数
    MAX_SERVER_PLAYERS = 15        -- 最大服务器人数（避免人多的服务器）
}

-- 目标物品列表
local TARGET_ITEMS = {
    "Money Printer",
    "Blue Candy Care",
    "Bunny Balloon",
    "Ghost Balloon",
    "Clover Balloon",
    "Bat Balloon",
    "Gold Clover Balloon",
    "Golden Rose",
    "Black Rose",
    "Heart Balloon",
    "Diamond Ring",
    "Diamond",
    "Vivid Gem",
    "Dark Matter Gem",
    "Rollie"
}

-- 创建物品名称映射表（提高搜索效率）
local itemMap = {}
for _, itemName in ipairs(TARGET_ITEMS) do
    itemMap[itemName:lower()] = true
end

-- 状态变量
local isRunning = true
local character = nil
local humanoid = nil
local humanoidRootPart = nil
local notificationGui = nil
local notificationLabel = nil
local stopButton = nil
local retryCount = 0
local currentServerId = game.JobId -- 当前服务器ID

-- 创建UI界面
local function createUI()
    if notificationGui and notificationGui.Parent then
        notificationGui:Destroy()
    end
    
    notificationGui = Instance.new("ScreenGui")
    notificationGui.Name = "AutoFarmUI"
    notificationGui.Parent = CoreGui
    notificationGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    notificationGui.ResetOnSpawn = false
    
    -- 通知框架
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0.25, 0, 0.1, 0)
    frame.Position = UDim2.new(0.7, 0, 0.82, 0)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BackgroundTransparency = 0.3
    frame.BorderSizePixel = 0
    frame.Parent = notificationGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(100, 100, 100)
    stroke.Thickness = 2
    stroke.Parent = frame
    
    -- 通知标签
    notificationLabel = Instance.new("TextLabel")
    notificationLabel.Size = UDim2.new(0.9, 0, 0.7, 0)
    notificationLabel.Position = UDim2.new(0.05, 0, 0.05, 0)
    notificationLabel.BackgroundTransparency = 1
    notificationLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    notificationLabel.TextScaled = false
    notificationLabel.TextSize = 14
    notificationLabel.TextWrapped = true
    notificationLabel.Font = Enum.Font.Gotham
    notificationLabel.Text = "rz自动换服捡物品启动中..."
    notificationLabel.TextXAlignment = Enum.TextXAlignment.Left
    notificationLabel.TextYAlignment = Enum.TextYAlignment.Top
    notificationLabel.Parent = frame
    
    -- 停止按钮框架
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = UDim2.new(0.8, 0, 0.2, 0)
    buttonFrame.Position = UDim2.new(0.1, 0, 0.75, 0)
    buttonFrame.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    buttonFrame.BackgroundTransparency = 0.2
    buttonFrame.BorderSizePixel = 0
    buttonFrame.Parent = frame
    
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = buttonFrame
    
    -- 停止按钮
    stopButton = Instance.new("TextButton")
    stopButton.Size = UDim2.new(1, 0, 1, 0)
    stopButton.BackgroundTransparency = 1
    stopButton.Text = "停止脚本"
    stopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    stopButton.TextSize = 14
    stopButton.Font = Enum.Font.GothamBold
    stopButton.Parent = buttonFrame
    
    -- 按钮点击事件
    stopButton.MouseButton1Click:Connect(function()
        isRunning = false
        if notificationLabel then
            notificationLabel.Text = "脚本已停止"
        end
        stopButton.Text = "已停止"
        stopButton.Active = false
    end)
    
    return notificationGui
end

-- 更新通知信息
local function updateNotification(text)
    if notificationLabel then
        notificationLabel.Text = tostring(text)
    end
    print("[INFO] " .. tostring(text))
end

-- 安全等待角色加载
local function waitForCharacter()
    local startTime = tick()
    while tick() - startTime < 10 and isRunning do
        if localPlayer.Character then
            character = localPlayer.Character
            humanoid = character:FindFirstChildOfClass("Humanoid")
            humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and humanoidRootPart and humanoid.Health > 0 then
                return true
            end
        end
        task.wait(0.5)
    end
    return false
end

-- 模拟按键按下
local function simulateKeyPress(keyCode, duration)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, nil)
    task.wait(duration or 0.1)
    VirtualInputManager:SendKeyEvent(false, keyCode, false, nil)
end

-- 模拟多次按键
local function simulateMultipleKeyPress(keyCode, count, delay)
    for i = 1, count do
        simulateKeyPress(keyCode, CONFIG.E_KEY_PRESS_DURATION)
        if delay and delay > 0 then
            task.wait(delay)
        end
    end
end

-- 安全传送到物品位置
local function safeTeleportToItem(item)
    if not item or not humanoidRootPart then
        return false
    end
    
    local success = pcall(function()
        -- 计算安全位置（避免卡在物体内）
        local offset = Vector3.new(0, 5, 0)
        local targetPosition = item.Position + offset
        humanoidRootPart.CFrame = CFrame.new(targetPosition)
    end)
    
    if success then
        task.wait(CONFIG.TELEPORT_DELAY)
        return true
    end
    
    return false
end

-- 改进的物品查找函数
local function findTargetItem()
    if not humanoidRootPart then return nil end
    
    local currentPosition = humanoidRootPart.Position
    local closestItem = nil
    local closestDistance = CONFIG.SEARCH_RADIUS
    
    -- 使用区域搜索提高效率
    for _, item in ipairs(Workspace:GetChildren()) do
        if item:IsA("BasePart") or item:IsA("MeshPart") or item:IsA("Part") then
            if itemMap[item.Name:lower()] then
                local distance = (item.Position - currentPosition).Magnitude
                if distance < closestDistance then
                    closestItem = item
                    closestDistance = distance
                end
            end
        end
    end
    
    -- 如果直接子级没找到，搜索整个工作区
    if not closestItem then
        for _, item in ipairs(Workspace:GetDescendants()) do
            if (item:IsA("BasePart") or item:IsA("MeshPart") or item:IsA("Part")) and item.Name then
                if itemMap[item.Name:lower()] then
                    local distance = (item.Position - currentPosition).Magnitude
                    if distance < closestDistance then
                        closestItem = item
                        closestDistance = distance
                    end
                end
            end
        end
    end
    
    return closestItem
end

-- 使用E键交互
local function interactWithEKey()
    -- 模拟按下E键多次
    simulateMultipleKeyPress(Enum.KeyCode.E, CONFIG.E_KEY_PRESS_COUNT, 0.1)
    return true
end

-- 获取服务器列表（使用Roblox API）
local function getServerList()
    local success, result = pcall(function()
        -- 使用Roblox API获取服务器列表
        local gameId = game.PlaceId
        local url = "https://games.roblox.com/v1/games/" .. gameId .. "/servers/Public?sortOrder=Asc&limit=100"
        
        local response = game:HttpGetAsync(url)
        local data = HttpService:JSONDecode(response)
        
        local servers = {}
        for _, server in ipairs(data.data) do
            if server.playing < CONFIG.MAX_SERVER_PLAYERS and server.id ~= currentServerId then
                table.insert(servers, {
                    id = server.id,
                    playing = server.playing
                })
            end
        end
        
        -- 按玩家数量排序
        table.sort(servers, function(a, b)
            return a.playing < b.playing
        end)
        
        return servers
    end)
    
    if not success then
        updateNotification("获取服务器列表失败，使用备用方案")
        -- 备用方案：返回模拟服务器列表
        local servers = {}
        for i = 1, 10 do
            table.insert(servers, {
                id = "Server_" .. tostring(i),
                playing = math.random(5, 15)
            })
        end
        
        table.sort(servers, function(a, b)
            return a.playing < b.playing
        end)
        
        return servers
    end
    
    return result
end

-- 获取当前服务器人数
local function getCurrentServerPlayers()
    return #Players:GetPlayers()
end

-- 安全切换服务器
local function safeSwitchServer()
    updateNotification("正在获取服务器列表...")
    local servers = getServerList()
    if #servers == 0 then 
        updateNotification("没有可用服务器")
        return false 
    end
    
    local bestServer = servers[1]
    updateNotification("切换到服务器\n玩家数量: " .. bestServer.playing)
    
    task.wait(CONFIG.SERVER_HOP_DELAY)
    
    local success = pcall(function()
        -- 尝试切换到新服务器
        TeleportService:TeleportToPlaceInstance(game.PlaceId, bestServer.id, localPlayer)
    end)
    
    if not success then
        updateNotification("换服失败，尝试备用方法")
        -- 备用方法：使用传统换服方式
        success = pcall(function()
            TeleportService:Teleport(game.PlaceId, localPlayer)
        end)
    end
    
    if success then
        -- 更新当前服务器ID
        currentServerId = bestServer.id
        return true
    end
    
    return false
end

-- 执行物品收集流程
local function executeCollectionRoutine()
    if not waitForCharacter() then
        updateNotification("角色加载失败")
        return false
    end
    
    local playerCount = getCurrentServerPlayers()
    updateNotification("服务器人数: " .. playerCount .. "\n搜索物品中...")
    
    local targetItem = findTargetItem()
    
    if targetItem then
        updateNotification("找到: " .. targetItem.Name .. "\n距离: " .. math.floor((targetItem.Position - humanoidRootPart.Position).Magnitude) .. "米\n传送中...")
        
        if safeTeleportToItem(targetItem) then
            updateNotification("传送成功\n使用E键交互中...")
            
            -- 使用E键交互
            interactWithEKey()
            updateNotification("E键交互完成\n等待换服...")
            task.wait(CONFIG.ITEM_PICKUP_DELAY)
            return true
        else
            updateNotification("传送失败\n等待换服...")
        end
    else
        updateNotification("未找到物品\n等待换服...")
    end
    
    task.wait(CONFIG.SERVER_HOP_DELAY)
    return false
end

-- 主循环函数
local function mainLoop()
    createUI()
    updateNotification("rz自动换服捡物品\n启动成功 - 1秒后开始")
    
    print("=== 自动脚本启动 ===")
    print("目标物品: " .. table.concat(TARGET_ITEMS, ", "))
    print("搜索半径: " .. CONFIG.SEARCH_RADIUS)
    task.wait(1)
    
    while isRunning do
        local success, err = pcall(function()
            -- 执行收集流程
            local collected = executeCollectionRoutine()
            
            -- 无论是否收集到物品，都尝试换服
            updateNotification("准备换服...")
            if not safeSwitchServer() then
                retryCount = retryCount + 1
                updateNotification("换服失败\n" .. CONFIG.RETRY_DELAY .. "秒后重试")
                if retryCount >= CONFIG.MAX_RETRY_ATTEMPTS then
                    updateNotification("达到最大重试次数\n脚本停止")
                    isRunning = false
                    return
                end
                task.wait(CONFIG.RETRY_DELAY)
            else
                -- 换服成功，重置重试计数
                retryCount = 0
                updateNotification("换服成功\n等待加载...")
                -- 等待一段时间让新服务器加载
                task.wait(5)
                -- 重新初始化角色引用
                character = nil
                humanoid = nil
                humanoidRootPart = nil
            end
        end)
        
        if not success then
            updateNotification("发生错误: " .. tostring(err))
            task.wait(CONFIG.RETRY_DELAY)
        end
    end
end

-- 添加游戏加载完成事件处理
local function onGameLoaded()
    -- 等待玩家加载完成
    while not localPlayer do
        localPlayer = Players.LocalPlayer
        task.wait(0.5)
    end
    
    -- 设置换服后自动重新启动脚本
    TeleportService.LocalPlayerOnTeleport:Connect(function(teleportState)
        if teleportState == Enum.TeleportState.InProgress then
            -- 保存当前脚本状态
            TeleportService:SetTeleportSetting("AutoFarmRunning", true)
        end
    end)
    
    -- 检查是否是从换服过来的
    if TeleportService:GetTeleportSetting("AutoFarmRunning") then
        TeleportService:SetTeleportSetting("AutoFarmRunning", false)
        task.wait(3) -- 等待角色加载
        mainLoop()
    else
        mainLoop()
    end
end

-- 启动脚本
if game:IsLoaded() then
    onGameLoaded()
else
    game.Loaded:Wait()
    onGameLoaded()
end
